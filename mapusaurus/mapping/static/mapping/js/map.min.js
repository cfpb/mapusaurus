"use strict";

function init() {
    blockStuff(), $.when(getTractsInBounds(getBoundParams()), getTractData(getBoundParams(), getActionTaken($("#action-taken-selector option:selected").val()))).done(function(data1, data2) {
        var hashInfo = getHashParams(), layerInfo = getLayerType(hashInfo.category.values);
        rawGeo = data1[0], rawData = data2[0], createTractDataObj(), redrawCircles(dataStore.tracts, layerInfo.type), 
        $.unblockUI(), isUIBlocked = !1;
    });
}

function setMapHeight() {
    var viewportHeight = $(window).height(), warningBannerHeight = $("#warning-banner").outerHeight(), headerHeight = $("#header").outerHeight(), mapHeaderHeight = $("#map-header").outerHeight(), mapHeight = viewportHeight - (warningBannerHeight + headerHeight + mapHeaderHeight);
    $("#map-aside").css("height", mapHeight), $("#map").css("height", mapHeight);
}

function toggleSuper(status) {
    var url = $("#download-data").data("super-download"), origUrl = $("#download-data").data("download");
    status ? ($("#lender-affiliate-list").removeClass("hidden"), $("#download-data").attr("href", url)) : ($("#lender-affiliate-list").addClass("hidden"), 
    $("#download-data").attr("href", origUrl)), addParam("lh", status), $("#superSelect").prop("checked", status);
}

function blockStuff() {
    return isUIBlocked === !0 ? !1 : (isUIBlocked = !0, void $.blockUI({
        css: {
            border: "none",
            padding: "15px",
            backgroundColor: "#000",
            "-webkit-border-radius": "10px",
            "-moz-border-radius": "10px",
            opacity: .5,
            color: "#fff"
        },
        message: '<img src="/static/basestyle/img/loading_white.gif" height="75px"> <h6>Loading HMDA Data</h6>',
        overlayCSS: {
            backgroundColor: "#000",
            opacity: 0,
            cursor: "wait"
        }
    }));
}

function getTractsInBounds(bounds, callback) {
    $("#bubbles_loading").show();
    var endpoint = "/api/tractCentroids/", params = {
        neLat: bounds.neLat,
        neLon: bounds.neLon,
        swLat: bounds.swLat,
        swLon: bounds.swLon
    };
    return $.ajax({
        url: endpoint,
        data: params,
        traditional: !0,
        success: console.log("tract Get successful")
    }).fail(function(status) {
        console.log("no data was available at" + endpoint + ". status: " + status);
    });
}

function getTractData(bounds, actionTakenVal, callback) {
    $("#bubbles_loading").show();
    var endpoint = "/api/all/", params = {
        year: 2013,
        lh: !1,
        neLat: bounds.neLat,
        neLon: bounds.neLon,
        swLat: bounds.swLat,
        swLon: bounds.swLon
    }, hash = getHashParams();
    return "undefined" != typeof hash.lh && (params.lh = hash.lh.values), urlParam("year") && (params.year = urlParam("year")), 
    urlParam("lender") ? (params.lender = urlParam("lender"), actionTakenVal ? params.action_taken = actionTakenVal : console.log("No action taken value - default (1-5) will be used."), 
    $.ajax({
        url: endpoint,
        data: params,
        traditional: !0,
        success: console.log("get API All Data request successful")
    }).fail(function(status) {
        console.log("no data was available at" + endpoint + ". status: " + status);
    })) : (console.log(" Lender parameter is required."), !1);
}

function createTractDataObj(callback) {
    dataStore.tracts = {}, _.each(rawGeo.features, function(feature) {
        var geoid = feature.properties.geoid;
        dataStore.tracts[geoid] = feature.properties, _.extend(dataStore.tracts[geoid], rawData.minority[geoid]), 
        "undefined" != typeof rawData.loanVolume[geoid] ? _.extend(dataStore.tracts[geoid], rawData.loanVolume[geoid]) : dataStore.tracts[geoid].volume = 0;
    }), "function" == typeof callback && callback();
}

function redrawCircles(geoData, layerType) {
    $("#bubbles_loading").show(), layers.Centroids.clearLayers(), _.each(geoData, function(geo) {
        drawCircle(geo, layerType);
    });
}

function updateCircles(layerType) {
    layers.Centroids.eachLayer(function(layer) {
        if (0 == layer.volume) return !1;
        if ("minority" == layerType) {
            var newStyle = {};
            _.extend(newStyle, baseStyle), newStyle.fillColor = updateMinorityCircleFill(layer.geoid), 
            layer.setStyle(newStyle);
        } else "seq" == layerType && layer.setStyle(seqBaseStyle);
    }), console.log("color update complete.");
}

function drawCircle(geo, layerType) {
    var style, data = geo;
    style = 0 === geo.total_pop || 0 === geo.volume ? noStyle : "seq" === layerType ? seqBaseStyle : minorityContinuousStyle(geo, baseStyle);
    var circle = L.circle([ geo.centlat, geo.centlon ], hmdaStat(data), style);
    circle.geoid = geo.geoid, circle.volume = geo.volume, circle.on("mouseover mousemove", function(e) {
        new L.Rrose({
            offset: new L.Point(0, 0),
            closeButton: !1,
            autoPan: !1
        }).setContent(data.volume + " records<br />" + data.num_households + " households<br />% White: " + 100 * data.non_hisp_white_only_perc + "<br /> % Hispanic: " + 100 * data.hispanic_perc + "<br />% Black: " + 100 * data.non_hisp_black_only_perc + "<br /> % Asian: " + 100 * data.non_hisp_asian_only_perc).setLatLng(e.latlng).openOn(map);
    }), circle.on("mouseout", function() {
        map.closePopup();
    }), layers.Centroids.addLayer(circle);
}

function minorityContinuousStyle(geoProps, baseStyle) {
    return minorityStyle(geoProps, function(minorityPercent, bucket) {
        return (minorityPercent - bucket.lowerBound) / bucket.span;
    }, baseStyle);
}

function minorityStyle(geoProps, percentFn, baseStyle) {
    var geoid = geoProps.geoid, tract = dataStore.tracts[geoid];
    if (0 === tract.total_pop || 0 === tract.volume) return noStyle;
    var perc = minorityPercent(tract), bucket = toBucket(perc), bucketPercent = percentFn(perc, bucket);
    return $.extend({}, baseStyle, {
        fillColor: colorFromPercent(bucketPercent, bucket.colors)
    });
}

function updateMinorityCircleFill(geoid) {
    var tract = dataStore.tracts[geoid];
    if (0 === tract.total_pop || 0 === tract.volume) return noStyle;
    var perc = minorityPercent(tract), bucket = toBucket(perc), bucketPercent = percentFn(perc, bucket);
    return colorFromPercent(bucketPercent, bucket.colors);
}

function percentFn(minorityPercent, bucket) {
    return (minorityPercent - bucket.lowerBound) / bucket.span;
}

function minorityPercent(tractData) {
    var fieldName = $("#category-selector option:selected").val();
    return "inv_" === fieldName.substring(0, 4) ? 1 - tractData[fieldName.substr(4)] : tractData[fieldName];
}

function toBucket(percent) {
    var i, len = colorRanges.length;
    for (i = 0; len - 1 > i; i++) if (colorRanges[i + 1].lowerBound > percent) return colorRanges[i];
    return colorRanges[len - 1];
}

function colorFromPercent(percent, c) {
    var diffR = (c.highR - c.lowR) * percent, diffG = (c.highG - c.lowG) * percent, diffB = (c.highB - c.lowB) * percent;
    return "rgb(" + (c.lowR + diffR).toFixed() + ", " + (c.lowG + diffG).toFixed() + ", " + (c.lowB + diffB).toFixed() + ")";
}

function hmdaStat(tractData) {
    var $selected = $("#action-taken-selector option:selected"), scale = ($selected.val(), 
    $selected.data("scale")), area = scale * tractData.volume;
    return Math.sqrt(area);
}

function getLayerType(layer) {
    var type;
    switch (layer) {
      case "inv_non_hisp_white_only_perc":
        layer = layers.PctMinority, type = "minority";
        break;

      case "hispanic_perc":
        layer = layers.PctHispanic, type = "minority";
        break;

      case "non_hisp_black_only_perc":
        layer = layers.PctBlack, type = "minority";
        break;

      case "non_hisp_asian_only_perc":
        layer = layers.PctAsian, type = "minority";
        break;

      case "non_hisp_white_only_perc":
        layer = layers.PctNonWhite, type = "minority";
        break;

      case "sequential3":
        layer = layers.Sequential3, type = "seq";
        break;

      case "sequential10":
        layer = layers.Sequential10, type = "seq";
        break;

      case "plurality":
        layer = layers.Plurality, type = "seq";
    }
    return {
        type: type,
        layer: layer
    };
}

function layerUpdate(layer) {
    var layerEval, mbLayer, layerType, keyPath;
    if (!layer) return console.log("The layer you've requested does not exist."), !1;
    for (var i = minorityLayers.length - 1; i >= 0; i--) map.removeLayer(minorityLayers[i]);
    switch (layer) {
      case "sequential3":
        keyPath = "/static/basestyle/img/fl_color-ramp_seq-03.png";
        break;

      case "sequential10":
        keyPath = "/static/basestyle/img/fl_color-ramp_seq-10.png";
        break;

      case "plurality":
        keyPath = "/static/basestyle/img/fl_color-ramp_plurality.png";
        break;

      case "default":
        keyPath = !1;
    }
    keyPath ? ($("#altScaleImg").attr("src", keyPath), $("#altScale").removeClass("hidden"), 
    $("#scale").addClass("hidden")) : ($("#altScale").addClass("hidden"), $("#scale").removeClass("hidden")), 
    layerEval = getLayerType(layer), mbLayer = layerEval.layer, layerType = layerEval.type, 
    map.addLayer(mbLayer), mbLayer.bringToFront(), layers.Water.bringToFront(), layers.Boundaries.bringToFront(), 
    layers.MSALabels.bringToFront(), map.hasLayer(layers.CountyLabels) && layers.CountyLabels.bringToFront(), 
    addParam("category", $("#category-selector option:selected").val()), updateCircles(layerType);
}

function urlParam(field) {
    var url = window.location.search.replace("?", ""), keyValueStrs = url.split("&"), pairs = _.map(keyValueStrs, function(keyValueStr) {
        return keyValueStr.split("=");
    }), params = _.reduce(pairs, function(soFar, pair) {
        return 2 === pair.length && (soFar[pair[0]] = pair[1]), soFar;
    }, {});
    return params[field];
}

function getActionTaken(value) {
    var actionTaken;
    switch (value) {
      case "all-apps-5":
        actionTaken = "1,2,3,4,5";
        break;

      case "all-apps-6":
        actionTaken = "1,2,3,4,5,6";
        break;

      case "originations-1":
        actionTaken = "1";
    }
    return actionTaken;
}

function getBoundParams() {
    var bounds = map.getBounds(), padding = 0;
    return {
        neLat: (bounds._northEast.lat + padding).toFixed(6),
        neLon: (bounds._northEast.lng + padding).toFixed(6),
        swLat: (bounds._southWest.lat - padding).toFixed(6),
        swLon: (bounds._southWest.lng - padding).toFixed(6)
    };
}

function getUniques(arr) {
    return _.uniq(arr);
}

window.console || (console = {
    log: function() {}
}), $(document).ready(function() {
    if ($(".tabs").show(), $(window).resize(function() {
        setMapHeight();
    }), $("#category-selector").on("change", function() {
        var val = $("#category-selector").val();
        layerUpdate(val);
    }), "undefined" != typeof loadParams.category ? ($("#category-selector").val(loadParams.category.values), 
    layerUpdate(loadParams.category.values)) : (addParam("category", "inv_non_hisp_white_only_perc"), 
    layerUpdate("inv_non_hisp_white_only_perc")), "undefined" != typeof loadParams.action ? $("#action-taken-selector").val(loadParams.action.values) : addParam("action", "all-apps-5"), 
    "undefined" != typeof loadParams.lh) {
        var status = "true" == loadParams.lh.values;
        $("#superSelect").prop("checked", status), toggleSuper(status);
    } else addParam("lh", !1);
    $("#superSelect").change(function() {
        var el = $("#superSelect"), status = el.prop("checked");
        toggleSuper(status), init();
    }), $("#action-taken-selector").on("change", function() {
        addParam("action", $("#action-taken-selector option:selected").val()), init();
    }), init();
});

var rawGeo, rawLar, rawMinority, rawData, isUIBlocked = !1, dataStore = {};

dataStore.tracts = {};

var baseStyle = {
    fillOpacity: .9,
    weight: .5,
    className: "lar-circle",
    fillColor: "#333"
}, seqBaseStyle = {
    fillOpacity: .7,
    weight: .75,
    className: "lar-circle seq-circle",
    fillColor: "#111111",
    stroke: !0,
    color: "#333",
    opacity: 1
}, noStyle = {
    stroke: !1,
    weight: 0,
    fill: !1
}, colorRanges = [ {
    span: .5,
    lowerBound: 0,
    colors: {
        lowR: 107,
        lowG: 40,
        lowB: 10,
        highR: 250,
        highG: 186,
        highB: 106
    }
}, {
    span: .5,
    lowerBound: .5,
    colors: {
        lowR: 124,
        lowG: 198,
        lowB: 186,
        highR: 12,
        highG: 48,
        highB: 97
    }
} ];
"use strict";

function getLarData(actionTakenVal, callback) {
    var params, endpoint = "/hmda/volume";
    params = {
        county: _.uniq(countiesPlotted)
    }, Mapusaurus.urlParam("lender") && (params.lender = Mapusaurus.urlParam("lender")), 
    actionTakenVal ? (params.action_taken = actionTakenVal, $.ajax({
        url: endpoint,
        data: params,
        traditional: !0,
        success: console.log("getLarData request successful")
    }).fail(function() {
        console.log("There was an error with your request", params);
    }).done(function(data) {
        callback(data);
    })) : console.log("Error: no action taken value");
}

function getLarDone(data) {
    _.each(Mapusaurus.dataStore.tract, function(num, key) {
        "undefined" != typeof num.layer_loanVolume ? "undefined" != typeof data[key] && (num.layer_loanVolume.volume = data[key].volume) : (data[key] = {}, 
        data[key].volume = 0);
    }), Mapusaurus.redrawBubbles(Mapusaurus.dataStore.tract);
}

function getActionTaken(value) {
    var actionTaken;
    switch (value) {
      case "all-apps-5":
        actionTaken = [ 1, 2, 3, 4, 5 ];
        break;

      case "all-apps-6":
        actionTaken = [ 1, 2, 3, 4, 5, 6 ];
        break;

      case "originations-1":
        actionTaken = [ 1 ];
    }
    return actionTaken;
}

function addParam(paramName, values) {
    var params = getHashParams();
    params[paramName].values = values, params[paramName].comparator = "=", updateUrlHash(params);
}

function getHashParams() {
    for (var e, hashParams = {}, a = /\+/g, r = /([^!&;=<>]+)(!?[=><]?)([^&;]*)/g, d = function(s) {
        return decodeURIComponent(s.replace(a, " "));
    }, q = window.location.hash.substring(1).replace(/^!\/?/, ""); e = r.exec(q); ) hashParams[d(e[1])] = {
        values: d(e[3]),
        comparator: d(e[2])
    };
    return hashParams;
}

function updateUrlHash(params) {
    function buildHashParam(param, name) {
        hashParams.push(name + "=" + param.values);
    }
    var newHash, hashParams = [];
    _.forEach(params, buildHashParam), newHash = "&" + hashParams.join("&"), window.location.hash = newHash;
}

function removeParam(params, removedParam) {
    var paramsCopy = $.extend(!0, {}, params);
    try {
        delete paramsCopy[removedParam];
    } catch (e) {}
    return delete paramsCopy.select, paramsCopy;
}

window.console || (console = {
    log: function() {}
});

var countiesPlotted = [];

L.TileLayer.GeoJSONData = L.TileLayer.Ajax.extend({
    addTileData: function(features, tilePoint) {
        this.options.filter && (features = _.filter(features, this.options.filter)), this.options.perGeo && _.each(features, this.options.perGeo), 
        this.options.postTileLoaded && this.options.postTileLoaded(features, tilePoint, this._tilesToLoad);
    },
    _tileLoaded: function(tile, tilePoint) {
        L.TileLayer.Ajax.prototype._tileLoaded.apply(this, arguments), null !== tile.datum && null !== tile.datum.features && (this.options.initialTransform && (tile.datum = this.options.initialTransform(tile.datum)), 
        this.addTileData(tile.datum.features, tilePoint));
    }
});

var Mapusaurus = {
    map: null,
    lockState: {
        locked: !1,
        geoid: null,
        outsideBubbles: []
    },
    layers: {
        tract: null,
        county: null,
        metro: null
    },
    dataStore: {
        tract: {}
    },
    toBatchLoad: [],
    drawn: {},
    notDrawn: function(feature) {
        return !_.has(Mapusaurus.drawn, feature.properties.geoid);
    },
    dataWithoutGeo: {
        minority: {}
    },
    statsLoaded: {
        minority: {}
    },
    bubbleStyle: {
        stroke: !1,
        fillOpacity: .9,
        weight: 2
    },
    tractStyle: {
        stroke: !1,
        fillOpacity: .25,
        weight: 2,
        fill: !0,
        smoothFactor: .1
    },
    loadingStyle: {
        stroke: !0,
        weight: 2,
        color: "#babbbd",
        fill: !1,
        smoothFactor: .1
    },
    outsideStyle: {
        stroke: !1,
        fill: !1
    },
    noStyle: {
        stroke: !1,
        fill: !1
    },
    zoomedCountyStyle: {
        stroke: !0,
        color: "#fff",
        weight: .5,
        fill: !1,
        opacity: 1
    },
    zoomedMetroStyle: {
        stroke: !0,
        color: "#fff",
        weight: 2,
        fill: !1,
        opacity: 1
    },
    biggerMetroStyle: {
        stroke: !0,
        color: "#646464",
        weight: 4,
        fill: !0,
        opacity: 1,
        dashArray: "20,10",
        fillColor: "#646464",
        fillOpacity: .5
    },
    initialize: function(map) {
        var mainEl = $("#map-container"), centLat = parseFloat(mainEl.data("cent-lat")) || 41.88, centLon = parseFloat(mainEl.data("cent-lon")) || -87.63, $enforceBoundsEl = $("#enforce-bounds");
        map.setView([ centLat, centLon ], 12), Mapusaurus.map = map, Mapusaurus.addKey(map), 
        new L.TileLayer.GeoJSONData("/shapes/topotiles/{z}/{x}/{y}", {
            filter: Mapusaurus.notDrawn,
            perGeo: Mapusaurus.handleGeo,
            initialTransform: Mapusaurus.extractTopo,
            postTileLoaded: Mapusaurus.afterShapeTile
        }).addTo(map), Mapusaurus.layers.tract = new L.GeoJSON(null, {
            style: Mapusaurus.minorityContinuousStyle,
            onEachFeature: Mapusaurus.eachTract
        }), Mapusaurus.layers.tract.addTo(map), Mapusaurus.layers.county = new L.GeoJSON(null, {
            style: Mapusaurus.zoomedCountyStyle,
            onEachFeature: Mapusaurus.dblclickToZoom
        }), Mapusaurus.layers.county.addTo(map), Mapusaurus.layers.metro = new L.GeoJSON(null, {
            style: Mapusaurus.zoomedMetroStyle,
            onEachFeature: Mapusaurus.dblclickToZoom
        }), Mapusaurus.layers.metro.addTo(map), Mapusaurus.urlParam("lender") && (Mapusaurus.layers.loanVolume = L.layerGroup([]), 
        Mapusaurus.layers.loanVolume.addTo(map), Mapusaurus.dataWithoutGeo.loanVolume = {}, 
        Mapusaurus.statsLoaded.loanVolume = {}, $("#bubble-selector").removeClass("hidden").on("change", Mapusaurus.redrawBubbles)), 
        $("#style-selector").on("change", function() {
            Mapusaurus.layers.tract.setStyle(Mapusaurus[$("#style-selector").val()]);
        }), $("#category-selector").on("change", function() {
            Mapusaurus.layers.tract.setStyle(Mapusaurus.pickStyle), Mapusaurus.redrawBubbles();
        }), $("#action-taken-selector").on("change", function() {
            var action_taken_value = $("#action-taken-selector").val(), action_taken = getActionTaken(action_taken_value);
            getLarData(action_taken, getLarDone);
        });
        var defaultLabel = $enforceBoundsEl.contents().text(), defaultTitle = $enforceBoundsEl.contents().attr("title"), unlockedLabel = $enforceBoundsEl.data("unlocked-label"), unlockedTitle = $enforceBoundsEl.data("unlocked-title");
        $enforceBoundsEl.click(function(e) {
            e.preventDefault(), "locked" === $(this).data("enforce-bounds-state") ? ($(this).data("enforce-bounds-state", "unlocked"), 
            $(this).contents().text(unlockedLabel).attr("title", unlockedTitle), Mapusaurus.disableBounds()) : ($(this).data("enforce-bounds-state", "locked"), 
            $(this).contents().text(defaultLabel).attr("title", defaultTitle), Mapusaurus.enforceBounds());
        }), $enforceBoundsEl.length > 0 && (Mapusaurus.lockState.geoid = mainEl.data("geoid").toString(), 
        Mapusaurus.enforceBounds());
    },
    extractTopo: function(tile) {
        return "Topology" === tile.type ? topojson.feature(tile, tile.objects.name) : tile;
    },
    isCounty: function(feature) {
        return 2 === feature.properties.geoType;
    },
    isTract: function(feature) {
        return 3 === feature.properties.geoType;
    },
    isMetro: function(feature) {
        return 4 === feature.properties.geoType;
    },
    afterShapeTile: function(features, tilePoint, tilesToLoad) {
        var tracts = _.filter(features, Mapusaurus.isTract);
        tracts = _.map(tracts, function(feature) {
            return feature.properties.geoid;
        }), Mapusaurus.updateDataWithoutGeos(tracts), Mapusaurus.fetchMissingStats(tracts, 0 === tilesToLoad);
        var action_taken_value = $("#action-taken-selector").val(), action_taken = getActionTaken(action_taken_value);
        getLarData(action_taken, getLarDone);
    },
    dblclickToZoom: function(feature, layer) {
        layer.on("dblclick", function(ev) {
            Mapusaurus.map.setZoomAround(ev.latlng, Mapusaurus.map.getZoom() + 1);
        });
    },
    pickStyle: function(feature) {
        var weightAtThisZoom, zoomLevel = Mapusaurus.map.getZoom(), zoomForWeight = Math.min(5, zoomLevel - 9);
        if (Mapusaurus.isTract(feature) && Mapusaurus.lockState.locked && feature.properties.cbsa !== Mapusaurus.lockState.geoid) return Mapusaurus.outsideStyle;
        if (Mapusaurus.isTract(feature)) return Mapusaurus.minorityContinuousStyle(feature.properties, Mapusaurus.tractStyle);
        if (zoomLevel > 8) {
            if (Mapusaurus.isCounty(feature)) return weightAtThisZoom = Mapusaurus.zoomedCountyStyle.weight + .5 * zoomForWeight, 
            $.extend({}, Mapusaurus.zoomedCountyStyle, {
                weight: weightAtThisZoom
            });
            if (Mapusaurus.isMetro(feature)) return weightAtThisZoom = Mapusaurus.zoomedMetroStyle.weight + 1 * zoomForWeight, 
            $.extend({}, Mapusaurus.zoomedMetroStyle, {
                weight: weightAtThisZoom
            });
        } else if (Mapusaurus.isMetro(feature)) return Mapusaurus.biggerMetroStyle;
    },
    reZIndex: function() {
        Mapusaurus.layers.metro.bringToBack(), Mapusaurus.layers.county.bringToBack(), Mapusaurus.layers.tract.bringToBack();
    },
    addKey: function(map) {
        var key = L.control();
        key.onAdd = function() {
            return L.DomUtil.get("key");
        }, key.addTo(map);
    },
    urlParam: function(field) {
        var url = window.location.search.replace("?", ""), keyValueStrs = url.split("&"), pairs = _.map(keyValueStrs, function(keyValueStr) {
            return keyValueStr.split("=");
        }), params = _.reduce(pairs, function(soFar, pair) {
            return 2 === pair.length && (soFar[pair[0]] = pair[1]), soFar;
        }, {});
        return params[field];
    },
    eachTract: function(feature, layer) {
        var geoid = feature.properties.geoid;
        Mapusaurus.dblclickToZoom(feature, layer), Mapusaurus.drawn[geoid] = !0, _.has(Mapusaurus.dataStore.tract, geoid) || (Mapusaurus.dataStore.tract[geoid] = feature.properties), 
        layer.on("mouseover mousemove", function(e) {
            var marker = new L.Rrose({
                offset: new L.Point(0, -10),
                closeButton: !1,
                autoPan: !1
            });
            Mapusaurus.dataStore.tract[geoid].marker = marker, marker.setContent(Mapusaurus.tractHoverText(geoid)).setLatLng(e.latlng).openOn(Mapusaurus.map);
        }), layer.on("mouseout", function() {
            Mapusaurus.map.closePopup();
        });
    },
    tractHoverText: function(geoid) {
        var tract = Mapusaurus.dataStore.tract[geoid];
        return _.has(tract, "layer_minority") ? (100 * Mapusaurus.minorityPercent(tract.layer_minority)).toFixed() + '% "Minority"<br />(' + $("#category-selector option:selected").text() + ")" : "Loading...";
    },
    updateDataWithoutGeos: function(newTracts) {
        var toDraw = {}, undrawnData = Mapusaurus.dataWithoutGeo;
        _.each(_.keys(undrawnData), function(layerName) {
            toDraw[layerName] = [], _.each(newTracts, function(geoid) {
                var geoProps = Mapusaurus.dataStore.tract[geoid];
                _.has(undrawnData[layerName], geoid) && (geoProps["layer_" + layerName] = undrawnData[layerName][geoid], 
                toDraw[layerName].push(geoid), delete undrawnData[layerName][geoid]);
            });
        }), Mapusaurus.draw(toDraw);
    },
    fetchMissingStats: function(newTracts, force) {
        var missingStats = [];
        _.each(_.keys(Mapusaurus.statsLoaded), function(layerName) {
            var missingData = _.filter(newTracts, function(geoid) {
                var geo = Mapusaurus.dataStore.tract[geoid], stateCounty = geo.state + geo.county;
                return countiesPlotted.push(stateCounty), !Mapusaurus.statsLoaded[layerName][stateCounty];
            });
            missingData = _.map(missingData, function(geoid) {
                var geo = Mapusaurus.dataStore.tract[geoid];
                return geo.state + geo.county;
            }), missingData = _.uniq(missingData), _.each(missingData, function(stateCounty) {
                missingStats.push([ layerName, stateCounty ]), Mapusaurus.statsLoaded[layerName][stateCounty] = "loading";
            });
        }), Mapusaurus.toBatchLoad.push(missingStats), (force || 10 === Mapusaurus.toBatchLoad.length) && (missingStats = _.flatten(Mapusaurus.toBatchLoad, !0), 
        Mapusaurus.toBatchLoad = [], missingStats.length > 0 && Mapusaurus.batchLoadStats(missingStats));
    },
    batchLoadStats: function(missingStats) {
        var params, endpoints = [], counties = [];
        _.each(missingStats, function(pair) {
            endpoints.push(pair[0]), counties.push(pair[1]);
        }), endpoints = _.uniq(endpoints), counties = _.uniq(counties), params = {
            endpoint: endpoints,
            county: counties
        }, Mapusaurus.urlParam("lender") && (params.lender = Mapusaurus.urlParam("lender")), 
        Mapusaurus.urlParam("action_taken") && (params.action_taken = Mapusaurus.urlParam("action_taken")), 
        $.ajax({
            url: "/batch",
            data: params,
            traditional: !0,
            success: Mapusaurus.makeBatchSuccessFn(endpoints, counties)
        });
    },
    makeBatchSuccessFn: function(endpoints, counties) {
        return function(data) {
            var toDraw = {};
            _.each(_.keys(Mapusaurus.statsLoaded), function(layerName) {
                toDraw[layerName] = [];
            }), _.each(endpoints, function(layerName) {
                var llName = "layer_" + layerName, response = data[layerName];
                _.each(_.keys(response), function(geoid) {
                    var geo = Mapusaurus.dataStore.tract[geoid];
                    geo ? geo[llName] || (geo[llName] = response[geoid], toDraw[layerName].push(geoid)) : Mapusaurus.dataWithoutGeo[layerName][geoid] = response[geoid];
                }), _.each(counties, function(county) {
                    Mapusaurus.statsLoaded[layerName][county] = !0;
                });
            }), Mapusaurus.draw(toDraw);
        };
    },
    draw: function(layerToGeoids) {
        _.each(_.keys(layerToGeoids), function(layerName) {
            var geoData = _.map(layerToGeoids[layerName], function(geoid) {
                return Mapusaurus.dataStore.tract[geoid];
            });
            switch (layerName) {
              case "minority":
                Mapusaurus.layers.tract.setStyle(Mapusaurus.pickStyle);
                break;

              case "loanVolume":
                _.each(geoData, function(geo) {
                    var bubble = Mapusaurus.makeBubble(geo);
                    geo.cbsa !== Mapusaurus.lockState.geoid && Mapusaurus.lockState.outsideBubbles.push(bubble), 
                    Mapusaurus.lockState.locked && geo.cbsa !== Mapusaurus.lockState.geoid || Mapusaurus.layers.loanVolume.addLayer(bubble);
                });
            }
        }), Mapusaurus.reZIndex();
    },
    hmdaStat: function(tractData) {
        var $selected = $("#action-taken-selector option:selected"), scale = ($selected.val(), 
        $selected.data("scale")), area = scale * tractData.volume;
        return Math.sqrt(area);
    },
    redrawBubbles: function() {
        Mapusaurus.lockState.locked ? _.each(Mapusaurus.lockState.outsideBubbles, function(bubble) {
            Mapusaurus.layers.loanVolume.removeLayer(bubble);
        }) : _.each(Mapusaurus.lockState.outsideBubbles, function(bubble) {
            Mapusaurus.layers.loanVolume.addLayer(bubble);
        }), Mapusaurus.layers.loanVolume.eachLayer(function(layer) {
            var geoid = layer.geoid, tractData = Mapusaurus.dataStore.tract[geoid], stat = Mapusaurus.hmdaStat(tractData.layer_loanVolume), style = Mapusaurus.minorityContinuousStyle(tractData, Mapusaurus.bubbleStyle);
            layer.setRadius(stat), layer.setStyle(style);
        });
    },
    makeBubble: function(geoProps) {
        var data = geoProps.layer_loanVolume, style = Mapusaurus.minorityContinuousStyle(geoProps, Mapusaurus.bubbleStyle), circle = L.circle([ geoProps.centlat, geoProps.centlon ], Mapusaurus.hmdaStat(data), style);
        return circle.geoid = geoProps.geoid, circle.on("dblclick", function(ev) {
            Mapusaurus.map.setZoomAround(ev.latlng, Mapusaurus.map.getZoom() + 1);
        }), circle.on("mouseover mousemove", function(e) {
            new L.Rrose({
                offset: new L.Point(0, -10),
                closeButton: !1,
                autoPan: !1
            }).setContent(data.volume + " records<br />" + data.num_households + " households").setLatLng(e.latlng).openOn(Mapusaurus.map);
        }), circle.on("mouseout", function() {
            Mapusaurus.map.closePopup();
        }), circle;
    },
    minorityContinuousStyle: function(geoProps, baseStyle) {
        return Mapusaurus.minorityStyle(geoProps, function(minorityPercent, bucket) {
            return (minorityPercent - bucket.lowerBound) / bucket.span;
        }, baseStyle);
    },
    minorityBucketedStyle: function(geoProps, baseStyle) {
        return Mapusaurus.minorityStyle(geoProps, function() {
            return .5;
        }, baseStyle);
    },
    minorityStyle: function(geoProps, percentFn, baseStyle) {
        var geoid = geoProps.geoid, tract = Mapusaurus.dataStore.tract[geoid];
        if (tract && _.has(tract, "layer_minority")) {
            if (0 === tract.layer_minority.total_pop) return Mapusaurus.noStyle;
            var perc = Mapusaurus.minorityPercent(tract.layer_minority), bucket = Mapusaurus.toBucket(perc), bucketPercent = percentFn(perc, bucket);
            return $.extend({}, baseStyle, {
                fillColor: Mapusaurus.colorFromPercent(bucketPercent, bucket.colors)
            });
        }
        return Mapusaurus.loadingStyle;
    },
    minorityPercent: function(tractData) {
        var fieldName = $("#category-selector").val();
        return "inv_" === fieldName.substring(0, 4) ? 1 - tractData[fieldName.substr(4)] : tractData[fieldName];
    },
    colorRanges: [ {
        span: .5,
        lowerBound: 0,
        colors: {
            lowR: 107,
            lowG: 40,
            lowB: 10,
            highR: 250,
            highG: 186,
            highB: 106
        }
    }, {
        span: .5,
        lowerBound: .5,
        colors: {
            lowR: 124,
            lowG: 198,
            lowB: 186,
            highR: 12,
            highG: 48,
            highB: 97
        }
    } ],
    toBucket: function(percent) {
        var i, len = Mapusaurus.colorRanges.length;
        for (i = 0; len - 1 > i; i++) if (Mapusaurus.colorRanges[i + 1].lowerBound > percent) return Mapusaurus.colorRanges[i];
        return Mapusaurus.colorRanges[len - 1];
    },
    colorFromPercent: function(percent, c) {
        var diffR = (c.highR - c.lowR) * percent, diffG = (c.highG - c.lowG) * percent, diffB = (c.highB - c.lowB) * percent;
        return "rgb(" + (c.lowR + diffR).toFixed() + ", " + (c.lowG + diffG).toFixed() + ", " + (c.lowB + diffB).toFixed() + ")";
    },
    enforceBounds: function() {
        var enforceEl = $("#enforce-bounds"), minLat = parseFloat(enforceEl.data("min-lat")), maxLat = parseFloat(enforceEl.data("max-lat")), minLon = parseFloat(enforceEl.data("min-lon")), maxLon = parseFloat(enforceEl.data("max-lon"));
        Mapusaurus.map.setMaxBounds([ [ minLat, minLon ], [ maxLat, maxLon ] ]), Mapusaurus.lockState.locked = !0, 
        Mapusaurus.layers.tract.setStyle(Mapusaurus.pickStyle), Mapusaurus.redrawBubbles();
    },
    disableBounds: function() {
        Mapusaurus.map.setMaxBounds(null), Mapusaurus.lockState.locked = !1, Mapusaurus.layers.tract.setStyle(Mapusaurus.pickStyle), 
        Mapusaurus.redrawBubbles();
    },
    handleGeo: function(geo) {
        Mapusaurus.drawn[geo.properties.geoid] = !0, Mapusaurus.isTract(geo) ? Mapusaurus.layers.tract.addData(geo) : Mapusaurus.isCounty(geo) ? Mapusaurus.layers.county.addData(geo) : Mapusaurus.isMetro(geo) && Mapusaurus.layers.metro.addData(geo);
    }
};
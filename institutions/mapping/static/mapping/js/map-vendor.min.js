(function() {
    var root = this, previousUnderscore = root._, ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype, push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind, _ = function(obj) {
        return obj instanceof _ ? obj : this instanceof _ ? void (this._wrapped = obj) : new _(obj);
    };
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = _), 
    exports._ = _) : root._ = _, _.VERSION = "1.7.0";
    var createCallback = function(func, context, argCount) {
        if (void 0 === context) return func;
        switch (null == argCount ? 3 : argCount) {
          case 1:
            return function(value) {
                return func.call(context, value);
            };

          case 2:
            return function(value, other) {
                return func.call(context, value, other);
            };

          case 3:
            return function(value, index, collection) {
                return func.call(context, value, index, collection);
            };

          case 4:
            return function(accumulator, value, index, collection) {
                return func.call(context, accumulator, value, index, collection);
            };
        }
        return function() {
            return func.apply(context, arguments);
        };
    };
    _.iteratee = function(value, context, argCount) {
        return null == value ? _.identity : _.isFunction(value) ? createCallback(value, context, argCount) : _.isObject(value) ? _.matches(value) : _.property(value);
    }, _.each = _.forEach = function(obj, iteratee, context) {
        if (null == obj) return obj;
        iteratee = createCallback(iteratee, context);
        var i, length = obj.length;
        if (length === +length) for (i = 0; length > i; i++) iteratee(obj[i], i, obj); else {
            var keys = _.keys(obj);
            for (i = 0, length = keys.length; length > i; i++) iteratee(obj[keys[i]], keys[i], obj);
        }
        return obj;
    }, _.map = _.collect = function(obj, iteratee, context) {
        if (null == obj) return [];
        iteratee = _.iteratee(iteratee, context);
        for (var currentKey, keys = obj.length !== +obj.length && _.keys(obj), length = (keys || obj).length, results = Array(length), index = 0; length > index; index++) currentKey = keys ? keys[index] : index, 
        results[index] = iteratee(obj[currentKey], currentKey, obj);
        return results;
    };
    var reduceError = "Reduce of empty array with no initial value";
    _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {
        null == obj && (obj = []), iteratee = createCallback(iteratee, context, 4);
        var currentKey, keys = obj.length !== +obj.length && _.keys(obj), length = (keys || obj).length, index = 0;
        if (arguments.length < 3) {
            if (!length) throw new TypeError(reduceError);
            memo = obj[keys ? keys[index++] : index++];
        }
        for (;length > index; index++) currentKey = keys ? keys[index] : index, memo = iteratee(memo, obj[currentKey], currentKey, obj);
        return memo;
    }, _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {
        null == obj && (obj = []), iteratee = createCallback(iteratee, context, 4);
        var currentKey, keys = obj.length !== +obj.length && _.keys(obj), index = (keys || obj).length;
        if (arguments.length < 3) {
            if (!index) throw new TypeError(reduceError);
            memo = obj[keys ? keys[--index] : --index];
        }
        for (;index--; ) currentKey = keys ? keys[index] : index, memo = iteratee(memo, obj[currentKey], currentKey, obj);
        return memo;
    }, _.find = _.detect = function(obj, predicate, context) {
        var result;
        return predicate = _.iteratee(predicate, context), _.some(obj, function(value, index, list) {
            return predicate(value, index, list) ? (result = value, !0) : void 0;
        }), result;
    }, _.filter = _.select = function(obj, predicate, context) {
        var results = [];
        return null == obj ? results : (predicate = _.iteratee(predicate, context), _.each(obj, function(value, index, list) {
            predicate(value, index, list) && results.push(value);
        }), results);
    }, _.reject = function(obj, predicate, context) {
        return _.filter(obj, _.negate(_.iteratee(predicate)), context);
    }, _.every = _.all = function(obj, predicate, context) {
        if (null == obj) return !0;
        predicate = _.iteratee(predicate, context);
        var index, currentKey, keys = obj.length !== +obj.length && _.keys(obj), length = (keys || obj).length;
        for (index = 0; length > index; index++) if (currentKey = keys ? keys[index] : index, 
        !predicate(obj[currentKey], currentKey, obj)) return !1;
        return !0;
    }, _.some = _.any = function(obj, predicate, context) {
        if (null == obj) return !1;
        predicate = _.iteratee(predicate, context);
        var index, currentKey, keys = obj.length !== +obj.length && _.keys(obj), length = (keys || obj).length;
        for (index = 0; length > index; index++) if (currentKey = keys ? keys[index] : index, 
        predicate(obj[currentKey], currentKey, obj)) return !0;
        return !1;
    }, _.contains = _.include = function(obj, target) {
        return null == obj ? !1 : (obj.length !== +obj.length && (obj = _.values(obj)), 
        _.indexOf(obj, target) >= 0);
    }, _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2), isFunc = _.isFunction(method);
        return _.map(obj, function(value) {
            return (isFunc ? method : value[method]).apply(value, args);
        });
    }, _.pluck = function(obj, key) {
        return _.map(obj, _.property(key));
    }, _.where = function(obj, attrs) {
        return _.filter(obj, _.matches(attrs));
    }, _.findWhere = function(obj, attrs) {
        return _.find(obj, _.matches(attrs));
    }, _.max = function(obj, iteratee, context) {
        var value, computed, result = -1/0, lastComputed = -1/0;
        if (null == iteratee && null != obj) {
            obj = obj.length === +obj.length ? obj : _.values(obj);
            for (var i = 0, length = obj.length; length > i; i++) value = obj[i], value > result && (result = value);
        } else iteratee = _.iteratee(iteratee, context), _.each(obj, function(value, index, list) {
            computed = iteratee(value, index, list), (computed > lastComputed || computed === -1/0 && result === -1/0) && (result = value, 
            lastComputed = computed);
        });
        return result;
    }, _.min = function(obj, iteratee, context) {
        var value, computed, result = 1/0, lastComputed = 1/0;
        if (null == iteratee && null != obj) {
            obj = obj.length === +obj.length ? obj : _.values(obj);
            for (var i = 0, length = obj.length; length > i; i++) value = obj[i], result > value && (result = value);
        } else iteratee = _.iteratee(iteratee, context), _.each(obj, function(value, index, list) {
            computed = iteratee(value, index, list), (lastComputed > computed || 1/0 === computed && 1/0 === result) && (result = value, 
            lastComputed = computed);
        });
        return result;
    }, _.shuffle = function(obj) {
        for (var rand, set = obj && obj.length === +obj.length ? obj : _.values(obj), length = set.length, shuffled = Array(length), index = 0; length > index; index++) rand = _.random(0, index), 
        rand !== index && (shuffled[index] = shuffled[rand]), shuffled[rand] = set[index];
        return shuffled;
    }, _.sample = function(obj, n, guard) {
        return null == n || guard ? (obj.length !== +obj.length && (obj = _.values(obj)), 
        obj[_.random(obj.length - 1)]) : _.shuffle(obj).slice(0, Math.max(0, n));
    }, _.sortBy = function(obj, iteratee, context) {
        return iteratee = _.iteratee(iteratee, context), _.pluck(_.map(obj, function(value, index, list) {
            return {
                value: value,
                index: index,
                criteria: iteratee(value, index, list)
            };
        }).sort(function(left, right) {
            var a = left.criteria, b = right.criteria;
            if (a !== b) {
                if (a > b || void 0 === a) return 1;
                if (b > a || void 0 === b) return -1;
            }
            return left.index - right.index;
        }), "value");
    };
    var group = function(behavior) {
        return function(obj, iteratee, context) {
            var result = {};
            return iteratee = _.iteratee(iteratee, context), _.each(obj, function(value, index) {
                var key = iteratee(value, index, obj);
                behavior(result, value, key);
            }), result;
        };
    };
    _.groupBy = group(function(result, value, key) {
        _.has(result, key) ? result[key].push(value) : result[key] = [ value ];
    }), _.indexBy = group(function(result, value, key) {
        result[key] = value;
    }), _.countBy = group(function(result, value, key) {
        _.has(result, key) ? result[key]++ : result[key] = 1;
    }), _.sortedIndex = function(array, obj, iteratee, context) {
        iteratee = _.iteratee(iteratee, context, 1);
        for (var value = iteratee(obj), low = 0, high = array.length; high > low; ) {
            var mid = low + high >>> 1;
            iteratee(array[mid]) < value ? low = mid + 1 : high = mid;
        }
        return low;
    }, _.toArray = function(obj) {
        return obj ? _.isArray(obj) ? slice.call(obj) : obj.length === +obj.length ? _.map(obj, _.identity) : _.values(obj) : [];
    }, _.size = function(obj) {
        return null == obj ? 0 : obj.length === +obj.length ? obj.length : _.keys(obj).length;
    }, _.partition = function(obj, predicate, context) {
        predicate = _.iteratee(predicate, context);
        var pass = [], fail = [];
        return _.each(obj, function(value, key, obj) {
            (predicate(value, key, obj) ? pass : fail).push(value);
        }), [ pass, fail ];
    }, _.first = _.head = _.take = function(array, n, guard) {
        return null == array ? void 0 : null == n || guard ? array[0] : 0 > n ? [] : slice.call(array, 0, n);
    }, _.initial = function(array, n, guard) {
        return slice.call(array, 0, Math.max(0, array.length - (null == n || guard ? 1 : n)));
    }, _.last = function(array, n, guard) {
        return null == array ? void 0 : null == n || guard ? array[array.length - 1] : slice.call(array, Math.max(array.length - n, 0));
    }, _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, null == n || guard ? 1 : n);
    }, _.compact = function(array) {
        return _.filter(array, _.identity);
    };
    var flatten = function(input, shallow, strict, output) {
        if (shallow && _.every(input, _.isArray)) return concat.apply(output, input);
        for (var i = 0, length = input.length; length > i; i++) {
            var value = input[i];
            _.isArray(value) || _.isArguments(value) ? shallow ? push.apply(output, value) : flatten(value, shallow, strict, output) : strict || output.push(value);
        }
        return output;
    };
    _.flatten = function(array, shallow) {
        return flatten(array, shallow, !1, []);
    }, _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
    }, _.uniq = _.unique = function(array, isSorted, iteratee, context) {
        if (null == array) return [];
        _.isBoolean(isSorted) || (context = iteratee, iteratee = isSorted, isSorted = !1), 
        null != iteratee && (iteratee = _.iteratee(iteratee, context));
        for (var result = [], seen = [], i = 0, length = array.length; length > i; i++) {
            var value = array[i];
            if (isSorted) i && seen === value || result.push(value), seen = value; else if (iteratee) {
                var computed = iteratee(value, i, array);
                _.indexOf(seen, computed) < 0 && (seen.push(computed), result.push(value));
            } else _.indexOf(result, value) < 0 && result.push(value);
        }
        return result;
    }, _.union = function() {
        return _.uniq(flatten(arguments, !0, !0, []));
    }, _.intersection = function(array) {
        if (null == array) return [];
        for (var result = [], argsLength = arguments.length, i = 0, length = array.length; length > i; i++) {
            var item = array[i];
            if (!_.contains(result, item)) {
                for (var j = 1; argsLength > j && _.contains(arguments[j], item); j++) ;
                j === argsLength && result.push(item);
            }
        }
        return result;
    }, _.difference = function(array) {
        var rest = flatten(slice.call(arguments, 1), !0, !0, []);
        return _.filter(array, function(value) {
            return !_.contains(rest, value);
        });
    }, _.zip = function(array) {
        if (null == array) return [];
        for (var length = _.max(arguments, "length").length, results = Array(length), i = 0; length > i; i++) results[i] = _.pluck(arguments, i);
        return results;
    }, _.object = function(list, values) {
        if (null == list) return {};
        for (var result = {}, i = 0, length = list.length; length > i; i++) values ? result[list[i]] = values[i] : result[list[i][0]] = list[i][1];
        return result;
    }, _.indexOf = function(array, item, isSorted) {
        if (null == array) return -1;
        var i = 0, length = array.length;
        if (isSorted) {
            if ("number" != typeof isSorted) return i = _.sortedIndex(array, item), array[i] === item ? i : -1;
            i = 0 > isSorted ? Math.max(0, length + isSorted) : isSorted;
        }
        for (;length > i; i++) if (array[i] === item) return i;
        return -1;
    }, _.lastIndexOf = function(array, item, from) {
        if (null == array) return -1;
        var idx = array.length;
        for ("number" == typeof from && (idx = 0 > from ? idx + from + 1 : Math.min(idx, from + 1)); --idx >= 0; ) if (array[idx] === item) return idx;
        return -1;
    }, _.range = function(start, stop, step) {
        arguments.length <= 1 && (stop = start || 0, start = 0), step = step || 1;
        for (var length = Math.max(Math.ceil((stop - start) / step), 0), range = Array(length), idx = 0; length > idx; idx++, 
        start += step) range[idx] = start;
        return range;
    };
    var Ctor = function() {};
    _.bind = function(func, context) {
        var args, bound;
        if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) throw new TypeError("Bind must be called on a function");
        return args = slice.call(arguments, 2), bound = function() {
            if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
            Ctor.prototype = func.prototype;
            var self = new Ctor();
            Ctor.prototype = null;
            var result = func.apply(self, args.concat(slice.call(arguments)));
            return _.isObject(result) ? result : self;
        };
    }, _.partial = function(func) {
        var boundArgs = slice.call(arguments, 1);
        return function() {
            for (var position = 0, args = boundArgs.slice(), i = 0, length = args.length; length > i; i++) args[i] === _ && (args[i] = arguments[position++]);
            for (;position < arguments.length; ) args.push(arguments[position++]);
            return func.apply(this, args);
        };
    }, _.bindAll = function(obj) {
        var i, key, length = arguments.length;
        if (1 >= length) throw new Error("bindAll must be passed function names");
        for (i = 1; length > i; i++) key = arguments[i], obj[key] = _.bind(obj[key], obj);
        return obj;
    }, _.memoize = function(func, hasher) {
        var memoize = function(key) {
            var cache = memoize.cache, address = hasher ? hasher.apply(this, arguments) : key;
            return _.has(cache, address) || (cache[address] = func.apply(this, arguments)), 
            cache[address];
        };
        return memoize.cache = {}, memoize;
    }, _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function() {
            return func.apply(null, args);
        }, wait);
    }, _.defer = function(func) {
        return _.delay.apply(_, [ func, 1 ].concat(slice.call(arguments, 1)));
    }, _.throttle = function(func, wait, options) {
        var context, args, result, timeout = null, previous = 0;
        options || (options = {});
        var later = function() {
            previous = options.leading === !1 ? 0 : _.now(), timeout = null, result = func.apply(context, args), 
            timeout || (context = args = null);
        };
        return function() {
            var now = _.now();
            previous || options.leading !== !1 || (previous = now);
            var remaining = wait - (now - previous);
            return context = this, args = arguments, 0 >= remaining || remaining > wait ? (clearTimeout(timeout), 
            timeout = null, previous = now, result = func.apply(context, args), timeout || (context = args = null)) : timeout || options.trailing === !1 || (timeout = setTimeout(later, remaining)), 
            result;
        };
    }, _.debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result, later = function() {
            var last = _.now() - timestamp;
            wait > last && last > 0 ? timeout = setTimeout(later, wait - last) : (timeout = null, 
            immediate || (result = func.apply(context, args), timeout || (context = args = null)));
        };
        return function() {
            context = this, args = arguments, timestamp = _.now();
            var callNow = immediate && !timeout;
            return timeout || (timeout = setTimeout(later, wait)), callNow && (result = func.apply(context, args), 
            context = args = null), result;
        };
    }, _.wrap = function(func, wrapper) {
        return _.partial(wrapper, func);
    }, _.negate = function(predicate) {
        return function() {
            return !predicate.apply(this, arguments);
        };
    }, _.compose = function() {
        var args = arguments, start = args.length - 1;
        return function() {
            for (var i = start, result = args[start].apply(this, arguments); i--; ) result = args[i].call(this, result);
            return result;
        };
    }, _.after = function(times, func) {
        return function() {
            return --times < 1 ? func.apply(this, arguments) : void 0;
        };
    }, _.before = function(times, func) {
        var memo;
        return function() {
            return --times > 0 ? memo = func.apply(this, arguments) : func = null, memo;
        };
    }, _.once = _.partial(_.before, 2), _.keys = function(obj) {
        if (!_.isObject(obj)) return [];
        if (nativeKeys) return nativeKeys(obj);
        var keys = [];
        for (var key in obj) _.has(obj, key) && keys.push(key);
        return keys;
    }, _.values = function(obj) {
        for (var keys = _.keys(obj), length = keys.length, values = Array(length), i = 0; length > i; i++) values[i] = obj[keys[i]];
        return values;
    }, _.pairs = function(obj) {
        for (var keys = _.keys(obj), length = keys.length, pairs = Array(length), i = 0; length > i; i++) pairs[i] = [ keys[i], obj[keys[i]] ];
        return pairs;
    }, _.invert = function(obj) {
        for (var result = {}, keys = _.keys(obj), i = 0, length = keys.length; length > i; i++) result[obj[keys[i]]] = keys[i];
        return result;
    }, _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) _.isFunction(obj[key]) && names.push(key);
        return names.sort();
    }, _.extend = function(obj) {
        if (!_.isObject(obj)) return obj;
        for (var source, prop, i = 1, length = arguments.length; length > i; i++) {
            source = arguments[i];
            for (prop in source) hasOwnProperty.call(source, prop) && (obj[prop] = source[prop]);
        }
        return obj;
    }, _.pick = function(obj, iteratee, context) {
        var key, result = {};
        if (null == obj) return result;
        if (_.isFunction(iteratee)) {
            iteratee = createCallback(iteratee, context);
            for (key in obj) {
                var value = obj[key];
                iteratee(value, key, obj) && (result[key] = value);
            }
        } else {
            var keys = concat.apply([], slice.call(arguments, 1));
            obj = new Object(obj);
            for (var i = 0, length = keys.length; length > i; i++) key = keys[i], key in obj && (result[key] = obj[key]);
        }
        return result;
    }, _.omit = function(obj, iteratee, context) {
        if (_.isFunction(iteratee)) iteratee = _.negate(iteratee); else {
            var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);
            iteratee = function(value, key) {
                return !_.contains(keys, key);
            };
        }
        return _.pick(obj, iteratee, context);
    }, _.defaults = function(obj) {
        if (!_.isObject(obj)) return obj;
        for (var i = 1, length = arguments.length; length > i; i++) {
            var source = arguments[i];
            for (var prop in source) void 0 === obj[prop] && (obj[prop] = source[prop]);
        }
        return obj;
    }, _.clone = function(obj) {
        return _.isObject(obj) ? _.isArray(obj) ? obj.slice() : _.extend({}, obj) : obj;
    }, _.tap = function(obj, interceptor) {
        return interceptor(obj), obj;
    };
    var eq = function(a, b, aStack, bStack) {
        if (a === b) return 0 !== a || 1 / a === 1 / b;
        if (null == a || null == b) return a === b;
        a instanceof _ && (a = a._wrapped), b instanceof _ && (b = b._wrapped);
        var className = toString.call(a);
        if (className !== toString.call(b)) return !1;
        switch (className) {
          case "[object RegExp]":
          case "[object String]":
            return "" + a == "" + b;

          case "[object Number]":
            return +a !== +a ? +b !== +b : 0 === +a ? 1 / +a === 1 / b : +a === +b;

          case "[object Date]":
          case "[object Boolean]":
            return +a === +b;
        }
        if ("object" != typeof a || "object" != typeof b) return !1;
        for (var length = aStack.length; length--; ) if (aStack[length] === a) return bStack[length] === b;
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && "constructor" in a && "constructor" in b && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor)) return !1;
        aStack.push(a), bStack.push(b);
        var size, result;
        if ("[object Array]" === className) {
            if (size = a.length, result = size === b.length) for (;size-- && (result = eq(a[size], b[size], aStack, bStack)); ) ;
        } else {
            var key, keys = _.keys(a);
            if (size = keys.length, result = _.keys(b).length === size) for (;size-- && (key = keys[size], 
            result = _.has(b, key) && eq(a[key], b[key], aStack, bStack)); ) ;
        }
        return aStack.pop(), bStack.pop(), result;
    };
    _.isEqual = function(a, b) {
        return eq(a, b, [], []);
    }, _.isEmpty = function(obj) {
        if (null == obj) return !0;
        if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return 0 === obj.length;
        for (var key in obj) if (_.has(obj, key)) return !1;
        return !0;
    }, _.isElement = function(obj) {
        return !(!obj || 1 !== obj.nodeType);
    }, _.isArray = nativeIsArray || function(obj) {
        return "[object Array]" === toString.call(obj);
    }, _.isObject = function(obj) {
        var type = typeof obj;
        return "function" === type || "object" === type && !!obj;
    }, _.each([ "Arguments", "Function", "String", "Number", "Date", "RegExp" ], function(name) {
        _["is" + name] = function(obj) {
            return toString.call(obj) === "[object " + name + "]";
        };
    }), _.isArguments(arguments) || (_.isArguments = function(obj) {
        return _.has(obj, "callee");
    }), "function" != typeof /./ && (_.isFunction = function(obj) {
        return "function" == typeof obj || !1;
    }), _.isFinite = function(obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
    }, _.isNaN = function(obj) {
        return _.isNumber(obj) && obj !== +obj;
    }, _.isBoolean = function(obj) {
        return obj === !0 || obj === !1 || "[object Boolean]" === toString.call(obj);
    }, _.isNull = function(obj) {
        return null === obj;
    }, _.isUndefined = function(obj) {
        return void 0 === obj;
    }, _.has = function(obj, key) {
        return null != obj && hasOwnProperty.call(obj, key);
    }, _.noConflict = function() {
        return root._ = previousUnderscore, this;
    }, _.identity = function(value) {
        return value;
    }, _.constant = function(value) {
        return function() {
            return value;
        };
    }, _.noop = function() {}, _.property = function(key) {
        return function(obj) {
            return obj[key];
        };
    }, _.matches = function(attrs) {
        var pairs = _.pairs(attrs), length = pairs.length;
        return function(obj) {
            if (null == obj) return !length;
            obj = new Object(obj);
            for (var i = 0; length > i; i++) {
                var pair = pairs[i], key = pair[0];
                if (pair[1] !== obj[key] || !(key in obj)) return !1;
            }
            return !0;
        };
    }, _.times = function(n, iteratee, context) {
        var accum = Array(Math.max(0, n));
        iteratee = createCallback(iteratee, context, 1);
        for (var i = 0; n > i; i++) accum[i] = iteratee(i);
        return accum;
    }, _.random = function(min, max) {
        return null == max && (max = min, min = 0), min + Math.floor(Math.random() * (max - min + 1));
    }, _.now = Date.now || function() {
        return new Date().getTime();
    };
    var escapeMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    }, unescapeMap = _.invert(escapeMap), createEscaper = function(map) {
        var escaper = function(match) {
            return map[match];
        }, source = "(?:" + _.keys(map).join("|") + ")", testRegexp = RegExp(source), replaceRegexp = RegExp(source, "g");
        return function(string) {
            return string = null == string ? "" : "" + string, testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
    };
    _.escape = createEscaper(escapeMap), _.unescape = createEscaper(unescapeMap), _.result = function(object, property) {
        if (null == object) return void 0;
        var value = object[property];
        return _.isFunction(value) ? object[property]() : value;
    };
    var idCounter = 0;
    _.uniqueId = function(prefix) {
        var id = ++idCounter + "";
        return prefix ? prefix + id : id;
    }, _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };
    var noMatch = /(.)^/, escapes = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, escaper = /\\|'|\r|\n|\u2028|\u2029/g, escapeChar = function(match) {
        return "\\" + escapes[match];
    };
    _.template = function(text, settings, oldSettings) {
        !settings && oldSettings && (settings = oldSettings), settings = _.defaults({}, settings, _.templateSettings);
        var matcher = RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join("|") + "|$", "g"), index = 0, source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
            return source += text.slice(index, offset).replace(escaper, escapeChar), index = offset + match.length, 
            escape ? source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'" : interpolate ? source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'" : evaluate && (source += "';\n" + evaluate + "\n__p+='"), 
            match;
        }), source += "';\n", settings.variable || (source = "with(obj||{}){\n" + source + "}\n"), 
        source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
        try {
            var render = new Function(settings.variable || "obj", "_", source);
        } catch (e) {
            throw e.source = source, e;
        }
        var template = function(data) {
            return render.call(this, data, _);
        }, argument = settings.variable || "obj";
        return template.source = "function(" + argument + "){\n" + source + "}", template;
    }, _.chain = function(obj) {
        var instance = _(obj);
        return instance._chain = !0, instance;
    };
    var result = function(obj) {
        return this._chain ? _(obj).chain() : obj;
    };
    _.mixin = function(obj) {
        _.each(_.functions(obj), function(name) {
            var func = _[name] = obj[name];
            _.prototype[name] = function() {
                var args = [ this._wrapped ];
                return push.apply(args, arguments), result.call(this, func.apply(_, args));
            };
        });
    }, _.mixin(_), _.each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            var obj = this._wrapped;
            return method.apply(obj, arguments), "shift" !== name && "splice" !== name || 0 !== obj.length || delete obj[0], 
            result.call(this, obj);
        };
    }), _.each([ "concat", "join", "slice" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            return result.call(this, method.apply(this._wrapped, arguments));
        };
    }), _.prototype.value = function() {
        return this._wrapped;
    }, "function" == typeof define && define.amd && define("underscore", [], function() {
        return _;
    });
}).call(this), !function() {
    function stitchArcs(topology, arcs) {
        function ends(i) {
            var p1, arc = topology.arcs[0 > i ? ~i : i], p0 = arc[0];
            return topology.transform ? (p1 = [ 0, 0 ], arc.forEach(function(dp) {
                p1[0] += dp[0], p1[1] += dp[1];
            })) : p1 = arc[arc.length - 1], 0 > i ? [ p1, p0 ] : [ p0, p1 ];
        }
        function flush(fragmentByEnd, fragmentByStart) {
            for (var k in fragmentByEnd) {
                var f = fragmentByEnd[k];
                delete fragmentByStart[f.start], delete f.start, delete f.end, f.forEach(function(i) {
                    stitchedArcs[0 > i ? ~i : i] = 1;
                }), fragments.push(f);
            }
        }
        var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
        return arcs.forEach(function(i, j) {
            var t, arc = topology.arcs[0 > i ? ~i : i];
            arc.length < 3 && !arc[1][0] && !arc[1][1] && (t = arcs[++emptyIndex], arcs[emptyIndex] = i, 
            arcs[j] = t);
        }), arcs.forEach(function(i) {
            var f, g, e = ends(i), start = e[0], end = e[1];
            if (f = fragmentByEnd[start]) if (delete fragmentByEnd[f.end], f.push(i), f.end = end, 
            g = fragmentByStart[end]) {
                delete fragmentByStart[g.start];
                var fg = g === f ? f : f.concat(g);
                fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
            } else fragmentByStart[f.start] = fragmentByEnd[f.end] = f; else if (f = fragmentByStart[end]) if (delete fragmentByStart[f.start], 
            f.unshift(i), f.start = start, g = fragmentByEnd[start]) {
                delete fragmentByEnd[g.end];
                var gf = g === f ? f : g.concat(f);
                fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
            } else fragmentByStart[f.start] = fragmentByEnd[f.end] = f; else f = [ i ], fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
        }), flush(fragmentByEnd, fragmentByStart), flush(fragmentByStart, fragmentByEnd), 
        arcs.forEach(function(i) {
            stitchedArcs[0 > i ? ~i : i] || fragments.push([ i ]);
        }), fragments;
    }
    function meshArcs(topology, o, filter) {
        function arc(i) {
            var j = 0 > i ? ~i : i;
            (geomsByArc[j] || (geomsByArc[j] = [])).push({
                i: i,
                g: geom
            });
        }
        function line(arcs) {
            arcs.forEach(arc);
        }
        function polygon(arcs) {
            arcs.forEach(line);
        }
        function geometry(o) {
            "GeometryCollection" === o.type ? o.geometries.forEach(geometry) : o.type in geometryType && (geom = o, 
            geometryType[o.type](o.arcs));
        }
        var arcs = [];
        if (arguments.length > 1) {
            var geom, geomsByArc = [], geometryType = {
                LineString: line,
                MultiLineString: polygon,
                Polygon: polygon,
                MultiPolygon: function(arcs) {
                    arcs.forEach(polygon);
                }
            };
            geometry(o), geomsByArc.forEach(arguments.length < 3 ? function(geoms) {
                arcs.push(geoms[0].i);
            } : function(geoms) {
                filter(geoms[0].g, geoms[geoms.length - 1].g) && arcs.push(geoms[0].i);
            });
        } else for (var i = 0, n = topology.arcs.length; n > i; ++i) arcs.push(i);
        return {
            type: "MultiLineString",
            arcs: stitchArcs(topology, arcs)
        };
    }
    function mergeArcs(topology, objects) {
        function register(polygon) {
            polygon.forEach(function(ring) {
                ring.forEach(function(arc) {
                    (polygonsByArc[arc = 0 > arc ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
                });
            }), polygons.push(polygon);
        }
        function exterior(ring) {
            return cartesianRingArea(object(topology, {
                type: "Polygon",
                arcs: [ ring ]
            }).coordinates[0]) > 0;
        }
        var polygonsByArc = {}, polygons = [], components = [];
        return objects.forEach(function(o) {
            "Polygon" === o.type ? register(o.arcs) : "MultiPolygon" === o.type && o.arcs.forEach(register);
        }), polygons.forEach(function(polygon) {
            if (!polygon._) {
                var component = [], neighbors = [ polygon ];
                for (polygon._ = 1, components.push(component); polygon = neighbors.pop(); ) component.push(polygon), 
                polygon.forEach(function(ring) {
                    ring.forEach(function(arc) {
                        polygonsByArc[0 > arc ? ~arc : arc].forEach(function(polygon) {
                            polygon._ || (polygon._ = 1, neighbors.push(polygon));
                        });
                    });
                });
            }
        }), polygons.forEach(function(polygon) {
            delete polygon._;
        }), {
            type: "MultiPolygon",
            arcs: components.map(function(polygons) {
                var arcs = [];
                if (polygons.forEach(function(polygon) {
                    polygon.forEach(function(ring) {
                        ring.forEach(function(arc) {
                            polygonsByArc[0 > arc ? ~arc : arc].length < 2 && arcs.push(arc);
                        });
                    });
                }), arcs = stitchArcs(topology, arcs), (n = arcs.length) > 1) for (var t, sgn = exterior(polygons[0][0]), i = 0; n > i; ++i) if (sgn === exterior(arcs[i])) {
                    t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;
                    break;
                }
                return arcs;
            })
        };
    }
    function featureOrCollection(topology, o) {
        return "GeometryCollection" === o.type ? {
            type: "FeatureCollection",
            features: o.geometries.map(function(o) {
                return feature(topology, o);
            })
        } : feature(topology, o);
    }
    function feature(topology, o) {
        var f = {
            type: "Feature",
            id: o.id,
            properties: o.properties || {},
            geometry: object(topology, o)
        };
        return null == o.id && delete f.id, f;
    }
    function object(topology, o) {
        function arc(i, points) {
            points.length && points.pop();
            for (var p, a = arcs[0 > i ? ~i : i], k = 0, n = a.length; n > k; ++k) points.push(p = a[k].slice()), 
            absolute(p, k);
            0 > i && reverse(points, n);
        }
        function point(p) {
            return p = p.slice(), absolute(p, 0), p;
        }
        function line(arcs) {
            for (var points = [], i = 0, n = arcs.length; n > i; ++i) arc(arcs[i], points);
            return points.length < 2 && points.push(points[0].slice()), points;
        }
        function ring(arcs) {
            for (var points = line(arcs); points.length < 4; ) points.push(points[0].slice());
            return points;
        }
        function polygon(arcs) {
            return arcs.map(ring);
        }
        function geometry(o) {
            var t = o.type;
            return "GeometryCollection" === t ? {
                type: t,
                geometries: o.geometries.map(geometry)
            } : t in geometryType ? {
                type: t,
                coordinates: geometryType[t](o)
            } : null;
        }
        var absolute = transformAbsolute(topology.transform), arcs = topology.arcs, geometryType = {
            Point: function(o) {
                return point(o.coordinates);
            },
            MultiPoint: function(o) {
                return o.coordinates.map(point);
            },
            LineString: function(o) {
                return line(o.arcs);
            },
            MultiLineString: function(o) {
                return o.arcs.map(line);
            },
            Polygon: function(o) {
                return polygon(o.arcs);
            },
            MultiPolygon: function(o) {
                return o.arcs.map(polygon);
            }
        };
        return geometry(o);
    }
    function reverse(array, n) {
        for (var t, j = array.length, i = j - n; i < --j; ) t = array[i], array[i++] = array[j], 
        array[j] = t;
    }
    function bisect(a, x) {
        for (var lo = 0, hi = a.length; hi > lo; ) {
            var mid = lo + hi >>> 1;
            a[mid] < x ? lo = mid + 1 : hi = mid;
        }
        return lo;
    }
    function neighbors(objects) {
        function line(arcs, i) {
            arcs.forEach(function(a) {
                0 > a && (a = ~a);
                var o = indexesByArc[a];
                o ? o.push(i) : indexesByArc[a] = [ i ];
            });
        }
        function polygon(arcs, i) {
            arcs.forEach(function(arc) {
                line(arc, i);
            });
        }
        function geometry(o, i) {
            "GeometryCollection" === o.type ? o.geometries.forEach(function(o) {
                geometry(o, i);
            }) : o.type in geometryType && geometryType[o.type](o.arcs, i);
        }
        var indexesByArc = {}, neighbors = objects.map(function() {
            return [];
        }), geometryType = {
            LineString: line,
            MultiLineString: polygon,
            Polygon: polygon,
            MultiPolygon: function(arcs, i) {
                arcs.forEach(function(arc) {
                    polygon(arc, i);
                });
            }
        };
        objects.forEach(geometry);
        for (var i in indexesByArc) for (var indexes = indexesByArc[i], m = indexes.length, j = 0; m > j; ++j) for (var k = j + 1; m > k; ++k) {
            var n, ij = indexes[j], ik = indexes[k];
            (n = neighbors[ij])[i = bisect(n, ik)] !== ik && n.splice(i, 0, ik), (n = neighbors[ik])[i = bisect(n, ij)] !== ij && n.splice(i, 0, ij);
        }
        return neighbors;
    }
    function presimplify(topology, triangleArea) {
        function update(triangle) {
            heap.remove(triangle), triangle[1][2] = triangleArea(triangle), heap.push(triangle);
        }
        var absolute = transformAbsolute(topology.transform), relative = transformRelative(topology.transform), heap = minAreaHeap();
        return triangleArea || (triangleArea = cartesianTriangleArea), topology.arcs.forEach(function(arc) {
            for (var triangle, p, triangles = [], maxArea = 0, i = 0, n = arc.length; n > i; ++i) p = arc[i], 
            absolute(arc[i] = [ p[0], p[1], 1/0 ], i);
            for (var i = 1, n = arc.length - 1; n > i; ++i) triangle = arc.slice(i - 1, i + 2), 
            triangle[1][2] = triangleArea(triangle), triangles.push(triangle), heap.push(triangle);
            for (var i = 0, n = triangles.length; n > i; ++i) triangle = triangles[i], triangle.previous = triangles[i - 1], 
            triangle.next = triangles[i + 1];
            for (;triangle = heap.pop(); ) {
                var previous = triangle.previous, next = triangle.next;
                triangle[1][2] < maxArea ? triangle[1][2] = maxArea : maxArea = triangle[1][2], 
                previous && (previous.next = next, previous[2] = triangle[2], update(previous)), 
                next && (next.previous = previous, next[0] = triangle[0], update(next));
            }
            arc.forEach(relative);
        }), topology;
    }
    function cartesianRingArea(ring) {
        for (var a, i = -1, n = ring.length, b = ring[n - 1], area = 0; ++i < n; ) a = b, 
        b = ring[i], area += a[0] * b[1] - a[1] * b[0];
        return .5 * area;
    }
    function cartesianTriangleArea(triangle) {
        var a = triangle[0], b = triangle[1], c = triangle[2];
        return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
    }
    function compareArea(a, b) {
        return a[1][2] - b[1][2];
    }
    function minAreaHeap() {
        function up(object, i) {
            for (;i > 0; ) {
                var j = (i + 1 >> 1) - 1, parent = array[j];
                if (compareArea(object, parent) >= 0) break;
                array[parent._ = i] = parent, array[object._ = i = j] = object;
            }
        }
        function down(object, i) {
            for (;;) {
                var r = i + 1 << 1, l = r - 1, j = i, child = array[j];
                if (size > l && compareArea(array[l], child) < 0 && (child = array[j = l]), size > r && compareArea(array[r], child) < 0 && (child = array[j = r]), 
                j === i) break;
                array[child._ = i] = child, array[object._ = i = j] = object;
            }
        }
        var heap = {}, array = [], size = 0;
        return heap.push = function(object) {
            return up(array[object._ = size] = object, size++), size;
        }, heap.pop = function() {
            if (!(0 >= size)) {
                var object, removed = array[0];
                return --size > 0 && (object = array[size], down(array[object._ = 0] = object, 0)), 
                removed;
            }
        }, heap.remove = function(removed) {
            var object, i = removed._;
            if (array[i] === removed) return i !== --size && (object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i)), 
            i;
        }, heap;
    }
    function transformAbsolute(transform) {
        if (!transform) return noop;
        var x0, y0, kx = transform.scale[0], ky = transform.scale[1], dx = transform.translate[0], dy = transform.translate[1];
        return function(point, i) {
            i || (x0 = y0 = 0), point[0] = (x0 += point[0]) * kx + dx, point[1] = (y0 += point[1]) * ky + dy;
        };
    }
    function transformRelative(transform) {
        if (!transform) return noop;
        var x0, y0, kx = transform.scale[0], ky = transform.scale[1], dx = transform.translate[0], dy = transform.translate[1];
        return function(point, i) {
            i || (x0 = y0 = 0);
            var x1 = (point[0] - dx) / kx | 0, y1 = (point[1] - dy) / ky | 0;
            point[0] = x1 - x0, point[1] = y1 - y0, x0 = x1, y0 = y1;
        };
    }
    function noop() {}
    var topojson = {
        version: "1.6.18",
        mesh: function(topology) {
            return object(topology, meshArcs.apply(this, arguments));
        },
        meshArcs: meshArcs,
        merge: function(topology) {
            return object(topology, mergeArcs.apply(this, arguments));
        },
        mergeArcs: mergeArcs,
        feature: featureOrCollection,
        neighbors: neighbors,
        presimplify: presimplify
    };
    "function" == typeof define && define.amd ? define(topojson) : "object" == typeof module && module.exports ? module.exports = topojson : this.topojson = topojson;
}(), L.TileLayer.Ajax = L.TileLayer.extend({
    _requests: [],
    _addTile: function(tilePoint) {
        var tile = {
            datum: null,
            processed: !1
        };
        this._tiles[tilePoint.x + ":" + tilePoint.y] = tile, this._loadTile(tile, tilePoint);
    },
    _xhrHandler: function(req, layer, tile, tilePoint) {
        return function() {
            if (4 === req.readyState) {
                var s = req.status;
                s >= 200 && 300 > s || 304 === s ? (tile.datum = JSON.parse(req.responseText), layer._tileLoaded(tile, tilePoint)) : layer._tileLoaded(tile, tilePoint);
            }
        };
    },
    _loadTile: function(tile, tilePoint) {
        this._adjustTilePoint(tilePoint);
        var layer = this, req = new XMLHttpRequest();
        this._requests.push(req), req.onreadystatechange = this._xhrHandler(req, layer, tile, tilePoint), 
        req.open("GET", this.getTileUrl(tilePoint), !0), req.send();
    },
    _reset: function() {
        L.TileLayer.prototype._reset.apply(this, arguments);
        for (var i in this._requests) this._requests[i].abort();
        this._requests = [];
    },
    _update: function() {
        this._map._panTransition && this._map._panTransition._inProgress || (this._tilesToLoad < 0 && (this._tilesToLoad = 0), 
        L.TileLayer.prototype._update.apply(this, arguments));
    }
}), L.TileLayer.GeoJSON = L.TileLayer.Ajax.extend({
    _keyLayers: {},
    _clipPathRectangles: {},
    initialize: function(url, options, geojsonOptions) {
        L.TileLayer.Ajax.prototype.initialize.call(this, url, options), this.geojsonLayer = new L.GeoJSON(null, geojsonOptions);
    },
    onAdd: function(map) {
        this._map = map, L.TileLayer.Ajax.prototype.onAdd.call(this, map), map.addLayer(this.geojsonLayer);
    },
    onRemove: function(map) {
        map.removeLayer(this.geojsonLayer), L.TileLayer.Ajax.prototype.onRemove.call(this, map);
    },
    _reset: function() {
        this.geojsonLayer.clearLayers(), this._keyLayers = {}, this._removeOldClipPaths(), 
        L.TileLayer.Ajax.prototype._reset.apply(this, arguments);
    },
    _removeOldClipPaths: function() {
        for (var clipPathId in this._clipPathRectangles) {
            var clipPathZXY = clipPathId.split("_").slice(1), zoom = parseInt(clipPathZXY[0], 10);
            if (zoom !== this._map.getZoom()) {
                var rectangle = this._clipPathRectangles[clipPathId];
                this._map.removeLayer(rectangle);
                var clipPath = document.getElementById(clipPathId);
                null !== clipPath && clipPath.parentNode.removeChild(clipPath), delete this._clipPathRectangles[clipPathId];
            }
        }
    },
    _recurseLayerUntilPath: function(func, layer) {
        layer instanceof L.Path ? func(layer) : layer instanceof L.LayerGroup && layer.getLayers().forEach(this._recurseLayerUntilPath.bind(this, func), this);
    },
    _clipLayerToTileBoundary: function(layer, tilePoint) {
        if (L.Path.SVG) {
            this._map._pathRoot || (this._map._pathRoot = L.Path.prototype._createElement("svg"), 
            this._map._panes.overlayPane.appendChild(this._map._pathRoot));
            var svg = this._map._pathRoot, defs = null;
            0 === svg.getElementsByTagName("defs").length ? (defs = document.createElementNS(L.Path.SVG_NS, "defs"), 
            svg.insertBefore(defs, svg.firstChild)) : defs = svg.getElementsByTagName("defs")[0];
            var clipPathId = "tileClipPath_" + tilePoint.z + "_" + tilePoint.x + "_" + tilePoint.y, clipPath = document.getElementById(clipPathId);
            if (null === clipPath) {
                clipPath = document.createElementNS(L.Path.SVG_NS, "clipPath"), clipPath.id = clipPathId;
                var tileSize = this.options.tileSize, nwPoint = tilePoint.multiplyBy(tileSize), sePoint = nwPoint.add([ tileSize, tileSize ]), nw = this._map.unproject(nwPoint), se = this._map.unproject(sePoint);
                this._clipPathRectangles[clipPathId] = new L.Rectangle(new L.LatLngBounds([ nw, se ]), {
                    opacity: 0,
                    fillOpacity: 0,
                    clickable: !1,
                    noClip: !0
                }), this._map.addLayer(this._clipPathRectangles[clipPathId]);
                var path = document.createElementNS(L.Path.SVG_NS, "path"), pathString = this._clipPathRectangles[clipPathId].getPathString();
                path.setAttribute("d", pathString), clipPath.appendChild(path), defs.appendChild(clipPath);
            }
            this._recurseLayerUntilPath(function(pathLayer) {
                pathLayer._container.setAttribute("clip-path", "url(#" + clipPathId + ")");
            }, layer);
        }
    },
    addTileData: function(geojson, tilePoint) {
        var i, len, feature, features = L.Util.isArray(geojson) ? geojson : geojson.features;
        if (features) {
            for (i = 0, len = features.length; len > i; i++) feature = features[i], (feature.geometries || feature.geometry || feature.features || feature.coordinates) && this.addTileData(features[i], tilePoint);
            return this;
        }
        var options = this.geojsonLayer.options;
        if (!options.filter || options.filter(geojson)) {
            var parentLayer = this.geojsonLayer, incomingLayer = null;
            if (this.options.unique && "function" == typeof this.options.unique) {
                var key = this.options.unique(geojson);
                key in this._keyLayers && "GeometryCollection" !== geojson.geometry.type || (geojson.geometry = {
                    type: "GeometryCollection",
                    geometries: [ geojson.geometry ]
                });
                try {
                    incomingLayer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng);
                } catch (e) {
                    return this;
                }
                incomingLayer.feature = L.GeoJSON.asFeature(geojson), key in this._keyLayers ? (parentLayer = this._keyLayers[key], 
                parentLayer.feature.geometry.geometries.push(geojson.geometry)) : this._keyLayers[key] = incomingLayer;
            } else {
                try {
                    incomingLayer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng);
                } catch (e) {
                    return this;
                }
                incomingLayer.feature = L.GeoJSON.asFeature(geojson);
            }
            return incomingLayer.defaultOptions = incomingLayer.options, this.geojsonLayer.resetStyle(incomingLayer), 
            options.onEachFeature && options.onEachFeature(geojson, incomingLayer), parentLayer.addLayer(incomingLayer), 
            this.options.clipTiles && this._clipLayerToTileBoundary(incomingLayer, tilePoint), 
            this;
        }
    },
    _tileLoaded: function(tile, tilePoint) {
        return L.TileLayer.Ajax.prototype._tileLoaded.apply(this, arguments), null === tile.datum ? null : void this.addTileData(tile.datum, tilePoint);
    }
});